From 284cef624d35be0d685c74b1e245117ce06c8ee2 Mon Sep 17 00:00:00 2001
From: unkernet <unkernet@gmail.com>
Date: Sun, 10 Aug 2025 07:11:22 +0700
Subject: [PATCH] MF1: Unify state reset logic

- Ensured state machine reset on CRC/parity errors and invalid operations across command handlers.
- Set `NFC_TAG_STATE_14A_PROPRIETARY` upon successful authentication to route subsequent commands only into the MF1 handler.
---
 .../application/src/rfid/nfctag/hf/nfc_14a.c  | 15 +++++++-
 .../application/src/rfid/nfctag/hf/nfc_14a.h  |  9 ++---
 .../application/src/rfid/nfctag/hf/nfc_mf1.c  | 34 +++++++++++++------
 .../application/src/rfid/nfctag/hf/nfc_mf1.h  |  1 +
 firmware/application/src/rgb_marquee.c        |  3 ++
 5 files changed, 47 insertions(+), 15 deletions(-)

diff --git a/firmware/application/src/rfid/nfctag/hf/nfc_14a.c b/firmware/application/src/rfid/nfctag/hf/nfc_14a.c
index 043f0e4d..0a3b7196 100644
--- a/firmware/application/src/rfid/nfctag/hf/nfc_14a.c
+++ b/firmware/application/src/rfid/nfctag/hf/nfc_14a.c
@@ -339,6 +339,11 @@ void nfc_tag_14a_data_process(uint8_t *p_data) {
         // The trigger conditions are: REQA response in non -Halt mode
         // Temporary through: Wupa response in non -choice state, no matter what state is in the state, you can use the Wupa instruction to wake up
         if ((szDataBits == 7) && ((isREQA && m_tag_state_14a != NFC_TAG_STATE_14A_HALTED) || isWUPA)) {
+            // Received 7-bit command (REQA or WUPA) while the tag is active â€” reset state machine
+            if (m_tag_state_14a != NFC_TAG_STATE_14A_IDLE && m_tag_state_14a != NFC_TAG_STATE_14A_HALTED) {
+                m_tag_state_14a = NFC_TAG_STATE_14A_IDLE;
+                return;
+            }
             // The receiver of the 14A communication is notified, the internal state machine is reset
             if (m_tag_handler.cb_reset != NULL) {
                 m_tag_handler.cb_reset();
@@ -517,8 +522,16 @@ void nfc_tag_14a_data_process(uint8_t *p_data) {
             // No processing is successful, it may be some other data. You need to re-post processing
             if (m_tag_handler.cb_state != NULL) {    //Activation status, transfer the message to other registered processor processing
                 m_tag_handler.cb_state(p_data, szDataBits);
-                break;
             }
+            break;
+        }
+        case NFC_TAG_STATE_14A_PROPRIETARY: {
+            if (m_tag_handler.cb_state != NULL) {
+                m_tag_handler.cb_state(p_data, szDataBits);
+            } else {
+                m_tag_state_14a = NFC_TAG_STATE_14A_IDLE;
+            }
+            break;
         }
     }
 }
diff --git a/firmware/application/src/rfid/nfctag/hf/nfc_14a.h b/firmware/application/src/rfid/nfctag/hf/nfc_14a.h
index c103c02f..9dbb5e8c 100644
--- a/firmware/application/src/rfid/nfctag/hf/nfc_14a.h
+++ b/firmware/application/src/rfid/nfctag/hf/nfc_14a.h
@@ -36,10 +36,11 @@
 
 // ISO14443-A Universal state machine
 typedef enum {
-    NFC_TAG_STATE_14A_IDLE,     // Leisure, you can wait for any instructions
-    NFC_TAG_STATE_14A_READY,    // Select card status, currently the standard 14A anti -rushing collision
-    NFC_TAG_STATE_14A_ACTIVE,   // Select cards or other instructions to enter the working status, which can receive all data
-    NFC_TAG_STATE_14A_HALTED,   // The label stops working status and can only be awakened by Halt or other special instructions (non -labels)
+    NFC_TAG_STATE_14A_IDLE,        // Leisure, you can wait for any instructions
+    NFC_TAG_STATE_14A_READY,       // Select card status, currently the standard 14A anti -rushing collision
+    NFC_TAG_STATE_14A_ACTIVE,      // Select cards or other instructions to enter the working status, which can receive all data
+    NFC_TAG_STATE_14A_HALTED,      // The label stops working status and can only be awakened by Halt or other special instructions (non -labels)
+    NFC_TAG_STATE_14A_PROPRIETARY, // Card is in proprietary state; all commands handled only by state_handler
 } nfc_tag_14a_state_t;
 
 // UID of the length in the enumeration specification
diff --git a/firmware/application/src/rfid/nfctag/hf/nfc_mf1.c b/firmware/application/src/rfid/nfctag/hf/nfc_mf1.c
index 3ae61643..ef99331f 100644
--- a/firmware/application/src/rfid/nfctag/hf/nfc_mf1.c
+++ b/firmware/application/src/rfid/nfctag/hf/nfc_mf1.c
@@ -578,6 +578,7 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                                 nfc_tag_14a_tx_bytes(m_tag_tx_buffer.tx_raw_buffer, NFC_TAG_MF1_DATA_SIZE, true);
                             } else {
                                 nfc_tag_14a_tx_nbit(NAK_INVALID_OPERATION_TBIV, 4);
+                                nfc_tag_mf1_reset_handler();
                             }
                             break;
                         }
@@ -591,6 +592,7 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                                 nfc_tag_14a_tx_nbit(ACK_VALUE, 4);
                             } else {
                                 nfc_tag_14a_tx_nbit(NAK_INVALID_OPERATION_TBIV, 4);
+                                nfc_tag_mf1_reset_handler();
                             }
                             break;
                         }
@@ -598,12 +600,14 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                             // When the state is not verified, read and write cards directly when the back door mode is turned on
                             // In addition to initiating verification instructions, the others can do nothing
                             nfc_tag_14a_tx_nbit(NAK_INVALID_OPERATION_TBIV, 4);
+                            nfc_tag_mf1_reset_handler();
                             break;
                         }
                     }
                 } else {
                     // CRC verification abnormal
                     nfc_tag_14a_tx_nbit(NAK_CRC_PARITY_ERROR_TBIV, 4);
+                    nfc_tag_mf1_reset_handler();
                     return;
                 }
             } else {
@@ -619,11 +623,12 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                     } else {
                         // The transmitted CRC verification is abnormal, and you cannot continue writing
                         nfc_tag_14a_tx_nbit(NAK_CRC_PARITY_ERROR_TBIV, 4);
+                        nfc_tag_mf1_reset_handler();
                     }
                 } else {
                     // If you wait for the instruction status to the non -4BYTE instruction, it is considered abnormal
                     // At this time, you need to reset the state machine
-                    nfc_tag_14a_set_state(NFC_TAG_STATE_14A_IDLE);
+                    nfc_tag_mf1_reset_handler();
                 }
             }
             break;
@@ -661,6 +666,7 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
 #endif
                     // The verification is successful, and you need to enter the state that has been successfully verified
                     m_mf1_state = MF1_STATE_AUTHENTICATED;
+                    nfc_tag_14a_set_state(NFC_TAG_STATE_14A_PROPRIETARY);
                     // Package, stitch the Qiqi school inspection, return
                     m_tag_tx_buffer.tx_frame_bit_size = nfc_tag_14a_wrap_frame(m_tag_tx_buffer.tx_raw_buffer, 32, m_tag_tx_buffer.tx_bit_parity, m_tag_tx_buffer.tx_warp_frame);
                     nfc_tag_14a_tx_bits(m_tag_tx_buffer.tx_warp_frame, m_tag_tx_buffer.tx_frame_bit_size);
@@ -668,12 +674,12 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                     // Temporary only stored verification failed logs
                     append_mf1_auth_log_step3(false);
                     // Verification failure, reset the status machine
-                    nfc_tag_14a_set_state(NFC_TAG_STATE_14A_IDLE);
+                    nfc_tag_mf1_reset_handler();
                 }
             } else {
                 // The length of the data sent by the reading head during the verification process is wrong, it must be a problem
                 // We can only reset the status machine and wait for the operation instructions to re -initiate
-                nfc_tag_14a_set_state(NFC_TAG_STATE_14A_IDLE);
+                nfc_tag_mf1_reset_handler();
             }
             break;
         }
@@ -736,10 +742,9 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                         case CMD_WRITE: {
                             //  Normal cards are not allowed to write block0, otherwise it will be recognized by CUID firewall
                             if (p_data[1] == 0x00 && !m_tag_information->config.mode_gen2_magic) {
-                                // Reset the 14A state machine directly, let the label sleep
-                                nfc_tag_14a_set_state(NFC_TAG_STATE_14A_HALTED);
-                                // Tell me to read the head. This operation is not allowed to be allowed
+                                // This operation is not allowed
                                 mf1_response_4bit_auto_encrypt(NAK_INVALID_OPERATION_TBIV);
+                                nfc_tag_mf1_reset_handler();
                             } else {
                                 // Normally write command.Store the address and prepare to receive the upcoming data.
                                 CurrentAddress = p_data[1];
@@ -783,6 +788,9 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                                 status = ACK_VALUE;
                             }
                             mf1_response_4bit_auto_encrypt(status);
+                            if (status != ACK_VALUE) {
+                                nfc_tag_mf1_reset_handler();
+                            }
                             break;
                         }
                         case CMD_AUTH_A:
@@ -892,24 +900,26 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                             } else {
                                 mf1_response_4bit_auto_encrypt(NAK_INVALID_OPERATION_TBIV);
                             }
+                            nfc_tag_mf1_reset_handler();
                             break;
                         }
                         default: {
                             // If you read your hair, you don't know what ghost instructions, we can't handle it,
                             // Therefore, the task is abnormal, and the status needs to be reset, and the response to the reading head will not support this instruction
-                            nfc_tag_14a_set_state(NFC_TAG_STATE_14A_IDLE);
                             mf1_response_4bit_auto_encrypt(NAK_INVALID_OPERATION_TBIV);
+                            nfc_tag_mf1_reset_handler();
                             break;
                         }
                     }
                 } else {
                     // CRC is wrong, return the error code notification
-                    mf1_response_4bit_auto_encrypt(NAK_INVALID_OPERATION_TBIV);
+                    mf1_response_4bit_auto_encrypt(NAK_CRC_PARITY_ERROR_TBIV);
+                    nfc_tag_mf1_reset_handler();
                     break;
                 }
             } else {
                 // It has been verified that the secrets are idle but did not receive the normal 4BYTE instructions, we need to reset the status machine
-                nfc_tag_14a_set_state(NFC_TAG_STATE_14A_IDLE);
+                nfc_tag_mf1_reset_handler();
                 break;
             }
             break;
@@ -948,6 +958,9 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
             // In any case, after the operation, the label will be allowed to return to the verification idle state
             m_mf1_state = MF1_STATE_AUTHENTICATED;
             mf1_response_4bit_auto_encrypt(status);
+            if (status != ACK_VALUE) {
+                nfc_tag_mf1_reset_handler();
+            }
             break;
         }
 
@@ -999,8 +1012,8 @@ void nfc_tag_mf1_state_handler(uint8_t *p_data, uint16_t szDataBits) {
                 // The length is wrong, but it is counted in the CRC error
                 status = NAK_CRC_PARITY_ERROR_TBIV;
             }
-            m_mf1_state = MF1_STATE_AUTHENTICATED;
             mf1_response_4bit_auto_encrypt(status);
+            nfc_tag_mf1_reset_handler();
             break;
         }
 
@@ -1054,6 +1067,7 @@ nfc_tag_14a_coll_res_reference_t *get_saved_mifare_coll_res() {
 void nfc_tag_mf1_reset_handler() {
     m_mf1_state = MF1_STATE_UNAUTHENTICATED;
     m_gen1a_state = GEN1A_STATE_DISABLE;
+    nfc_tag_14a_set_state(NFC_TAG_STATE_14A_IDLE);
 
 #ifndef NFC_MF1_FAST_SIM
     // Must to reset pcs handler
diff --git a/firmware/application/src/rfid/nfctag/hf/nfc_mf1.h b/firmware/application/src/rfid/nfctag/hf/nfc_mf1.h
index 35217149..54f531c9 100644
--- a/firmware/application/src/rfid/nfctag/hf/nfc_mf1.h
+++ b/firmware/application/src/rfid/nfctag/hf/nfc_mf1.h
@@ -140,6 +140,7 @@ typedef struct {
 
 
 nfc_tag_mf1_auth_log_t *mf1_get_auth_log(uint32_t *count);
+void nfc_tag_mf1_reset_handler();
 int nfc_tag_mf1_data_loadcb(tag_specific_type_t type, tag_data_buffer_t *buffer);
 int nfc_tag_mf1_data_savecb(tag_specific_type_t type, tag_data_buffer_t *buffer);
 bool nfc_tag_mf1_data_factory(uint8_t slot, tag_specific_type_t tag_type);
diff --git a/firmware/application/src/rgb_marquee.c b/firmware/application/src/rgb_marquee.c
index 42416683..d8a8c8e4 100644
--- a/firmware/application/src/rgb_marquee.c
+++ b/firmware/application/src/rgb_marquee.c
@@ -238,6 +238,9 @@ void ledblink3(uint8_t led_down, uint8_t color_led_down, uint8_t led_up, uint8_t
             light_level --;
         }
     }
+    for (uint8_t i = 0; i < RGB_LIST_NUM; i++) {
+        nrf_gpio_pin_clear(led_pins[i]);
+    }
     if (led_up >= 0 && led_up <= 7) {
         //Treatment
         pwm_config.output_pins[0] = led_pins[led_up];
